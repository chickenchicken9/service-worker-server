importScripts('shared.js');

const openDb = indexedDB.open('db', 5);
let db;
openDb.onsuccess = (event) => {
    console.log('opened db!');
    db = event.target.result;
};

self.addEventListener('install', (event) => {
    console.log('worker installing');
    self.skipWaiting();
    event.waitUntil(Promise.resolve());
});

const workerPathRegex = /.*(\/worker\/[a-z]+)/;
self.addEventListener("fetch", (event) => {
    console.log('fetch:', event);
    const url = new URL(event.request.url);

    // Ignore non-/worker/... URLs.
    const workerPath = url.pathname.match(workerPathRegex)?.[1];
    if (!workerPath) return;

    event.respondWith(new Promise((resolve, reject) => {
        db
            .transaction('store')
            .objectStore('store')
            .get(workerPath).onsuccess = (dbEvent) => {
                if (!dbEvent.target.result) {
                    console.log(`no db entry for ${url.pathname}`);
                    const notFoundResponse = `
                        <html>
                        <head><title>generated but not found</title></head>
                        <body>
                        <h1>This page was auto-generated by the service worker :)</h1>
                        <pre>
                        hi!\n
                        method: ${event.request.method}\n
                        URL: ${event.request.url}\n
                        headers: ${JSON.stringify(Object.fromEntries(event.request.headers))}
                        </pre>
                        </body>
                        </html>
                    `;
                    resolve(
                        new Response(notFoundResponse, {
                            status: 200,
                            statusText: 'OK',
                            headers: {
                                'Content-Type': 'text/html'
                            }
                        }));
                } else {
                    const result = run(dbEvent.target.result.fn);
                    console.log(`Handling fetch! Result:\n
                        Globals: ${Object.keys(result?.globals)}\n
                        Value: ${result?.value}\n
                        Errors: ${result.errors}\n
                    `);
                    resolve(
                        new Response(result?.value(), {
                            status: 200,
                            statusText: 'OK',
                            headers: {
                                'Content-Type': 'text/html'
                            }
                        }));
                }
            };
    }));
});

self.onmessage = (event) => {
    console.log(`The client sent me a message: ${event.data}`);
    const result = run(event.data);
    event.source.postMessage(`
        Globals: ${Object.keys(result?.globals)}\n
        Value: ${result?.value}\n
        Errors: ${result.errors}\n
    `);
};